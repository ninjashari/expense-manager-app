/**
 * @file credit-card-bill-service.ts
 * @description This file contains credit card bill service functions for database operations.
 * It provides comprehensive bill management, payment tracking, and automatic bill generation.
 */

import { query, queryOne, transaction } from '@/lib/database'
import { 
  CreditCardBill, 
  CreditCardBillStatus,
  BillGenerationParams,
  BillPaymentInfo,
  calculateMinimumPayment,
  determineBillStatus 
} from '@/types/credit-card'
import { getAccounts } from './account-service'

/**
 * Database row interface for credit card bills
 * @description Structure of credit card bill data as stored in PostgreSQL
 */
interface CreditCardBillRow {
  id: string
  user_id: string
  account_id: string
  bill_period_start: string
  bill_period_end: string
  bill_generation_date: string
  payment_due_date: string
  previous_balance: number
  total_spending: number
  total_payments: number
  bill_amount: number
  minimum_payment: number
  status: CreditCardBillStatus
  paid_amount: number
  paid_date: string | null
  transaction_ids: string[]
  payment_transaction_ids: string[]
  is_auto_generated: boolean
  notes: string | null
  created_at: string
  updated_at: string
}

/**
 * Transform database row to CreditCardBill interface
 * @description Converts PostgreSQL row data to application interface
 * @param row - Database row data
 * @returns CreditCardBill interface
 */
function transformRowToBill(row: CreditCardBillRow): CreditCardBill {
  return {
    id: row.id,
    userId: row.user_id,
    accountId: row.account_id,
    billPeriodStart: new Date(row.bill_period_start),
    billPeriodEnd: new Date(row.bill_period_end),
    billGenerationDate: new Date(row.bill_generation_date),
    paymentDueDate: new Date(row.payment_due_date),
    previousBalance: Number(row.previous_balance) || 0,
    totalSpending: Number(row.total_spending) || 0,
    totalPayments: Number(row.total_payments) || 0,
    billAmount: Number(row.bill_amount) || 0,
    minimumPayment: Number(row.minimum_payment) || 0,
    status: row.status,
    paidAmount: Number(row.paid_amount) || 0,
    paidDate: row.paid_date ? new Date(row.paid_date) : undefined,
    transactionIds: row.transaction_ids,
    paymentTransactionIds: row.payment_transaction_ids,
    isAutoGenerated: row.is_auto_generated,
    notes: row.notes || undefined,
    createdAt: new Date(row.created_at),
    updatedAt: new Date(row.updated_at)
  }
}

/**
 * Get credit card bills for a user
 * @description Retrieves all credit card bills for a user, optionally filtered by account
 * @param userId - User ID to filter bills
 * @param accountId - Optional account ID to filter bills
 * @returns Promise resolving to array of credit card bills
 */
export async function getCreditCardBills(userId: string, accountId?: string): Promise<CreditCardBill[]> {
  try {
    let queryText = `
      SELECT * FROM credit_card_bills 
      WHERE user_id = $1
    `
    const params: string[] = [userId]

    if (accountId) {
      queryText += ` AND account_id = $2`
      params.push(accountId)
    }

    queryText += ` ORDER BY bill_generation_date DESC, created_at DESC`

    const rows = await query<CreditCardBillRow>(queryText, params)
    return rows.map(transformRowToBill)
  } catch (error) {
    console.error('Error fetching credit card bills:', error)
    throw new Error('Failed to fetch credit card bills')
  }
}

/**
 * Get credit card bill by ID
 * @description Retrieves a specific credit card bill by ID
 * @param billId - Bill ID
 * @param userId - User ID for authorization
 * @returns Promise resolving to credit card bill or null
 */
export async function getCreditCardBillById(billId: string, userId: string): Promise<CreditCardBill | null> {
  try {
    const row = await queryOne<CreditCardBillRow>(
      'SELECT * FROM credit_card_bills WHERE id = $1 AND user_id = $2',
      [billId, userId]
    )
    
    return row ? transformRowToBill(row) : null
  } catch (error) {
    console.error('Error fetching credit card bill by ID:', error)
    throw new Error('Failed to fetch credit card bill')
  }
}

/**
 * Create credit card bill
 * @description Creates a new credit card bill
 * @param billData - Bill generation parameters
 * @param userId - User ID for authorization
 * @returns Promise resolving to created credit card bill
 */
export async function createCreditCardBill(billData: BillGenerationParams, userId: string): Promise<CreditCardBill> {
  try {
    const minimumPayment = calculateMinimumPayment(billData.previousBalance || 0)
    
    const row = await queryOne<CreditCardBillRow>(
      `
      INSERT INTO credit_card_bills (
        user_id, account_id, bill_period_start, bill_period_end,
        bill_generation_date, payment_due_date, previous_balance,
        total_spending, total_payments, bill_amount, minimum_payment,
        status, paid_amount, is_auto_generated
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
      ) RETURNING *
      `,
      [
        userId,
        billData.accountId,
        billData.billPeriodStart.toISOString().split('T')[0],
        billData.billPeriodEnd.toISOString().split('T')[0],
        billData.billGenerationDate.toISOString().split('T')[0],
        billData.paymentDueDate.toISOString().split('T')[0],
        billData.previousBalance || 0,
        0, // total_spending - will be calculated
        0, // total_payments - will be calculated
        billData.previousBalance || 0, // bill_amount - will be calculated
        minimumPayment,
        'generated',
        0, // paid_amount
        true // is_auto_generated
      ]
    )

    if (!row) {
      throw new Error('Failed to create credit card bill')
    }

    return transformRowToBill(row)
  } catch (error) {
    console.error('Error creating credit card bill:', error)
    throw new Error('Failed to create credit card bill')
  }
}

/**
 * Update credit card bill
 * @description Updates an existing credit card bill
 * @param billId - Bill ID
 * @param updateData - Data to update
 * @param userId - User ID for authorization
 * @returns Promise resolving to updated credit card bill or null
 */
export async function updateCreditCardBill(
  billId: string, 
  updateData: Partial<CreditCardBill>, 
  userId: string
): Promise<CreditCardBill | null> {
  try {
    const setClause: string[] = []
    const params: unknown[] = []
    let paramIndex = 1

    // Build dynamic SET clause
    if (updateData.status !== undefined) {
      setClause.push(`status = $${paramIndex++}`)
      params.push(updateData.status)
    }
    if (updateData.paidAmount !== undefined) {
      setClause.push(`paid_amount = $${paramIndex++}`)
      params.push(updateData.paidAmount)
    }
    if (updateData.paidDate !== undefined) {
      setClause.push(`paid_date = $${paramIndex++}`)
      params.push(updateData.paidDate?.toISOString().split('T')[0])
    }
    if (updateData.notes !== undefined) {
      setClause.push(`notes = $${paramIndex++}`)
      params.push(updateData.notes)
    }
    
    setClause.push(`updated_at = $${paramIndex++}`)
    params.push(new Date().toISOString())

    params.push(billId, userId)

    const row = await queryOne<CreditCardBillRow>(
      `
      UPDATE credit_card_bills 
      SET ${setClause.join(', ')}
      WHERE id = $${paramIndex++} AND user_id = $${paramIndex++}
      RETURNING *
      `,
      params
    )

    return row ? transformRowToBill(row) : null
  } catch (error) {
    console.error('Error updating credit card bill:', error)
    throw new Error('Failed to update credit card bill')
  }
}

/**
 * Delete credit card bill
 * @description Deletes a credit card bill
 * @param billId - Bill ID
 * @param userId - User ID for authorization
 * @returns Promise resolving to success status
 */
export async function deleteCreditCardBill(billId: string, userId: string): Promise<boolean> {
  try {
    const result = await query(
      'DELETE FROM credit_card_bills WHERE id = $1 AND user_id = $2',
      [billId, userId]
    )
    
    return result.length > 0
  } catch (error) {
    console.error('Error deleting credit card bill:', error)
    throw new Error('Failed to delete credit card bill')
  }
}

/**
 * Record bill payment
 * @description Records a payment against a credit card bill
 * @param paymentInfo - Payment information
 * @param userId - User ID for authorization
 * @returns Promise resolving to updated credit card bill or null
 */
export async function recordBillPayment(
  paymentInfo: BillPaymentInfo, 
  userId: string
): Promise<CreditCardBill | null> {
  try {
    return await transaction(async (client) => {
      // Get current bill
      const billResult = await client.query(
        'SELECT * FROM credit_card_bills WHERE id = $1 AND user_id = $2',
        [paymentInfo.billId, userId]
      )

      if (billResult.rows.length === 0) {
        return null
      }

      const currentBill = billResult.rows[0]
      const newPaidAmount = currentBill.paid_amount + paymentInfo.paymentAmount
      
      // Determine new status
      const newStatus = determineBillStatus(
        currentBill.bill_amount,
        newPaidAmount,
        new Date(currentBill.payment_due_date),
        paymentInfo.paymentDate
      )

      // Update payment transaction IDs if provided
      const paymentTransactionIds = paymentInfo.paymentTransactionId 
        ? [...currentBill.payment_transaction_ids, paymentInfo.paymentTransactionId]
        : currentBill.payment_transaction_ids

      // Update the bill
      const updateResult = await client.query(
        `
        UPDATE credit_card_bills 
        SET 
          paid_amount = $1,
          paid_date = $2,
          status = $3,
          payment_transaction_ids = $4,
          notes = COALESCE($5, notes),
          updated_at = NOW()
        WHERE id = $6 AND user_id = $7
        RETURNING *
        `,
        [
          newPaidAmount,
          paymentInfo.paymentDate.toISOString().split('T')[0],
          newStatus,
          paymentTransactionIds,
          paymentInfo.notes,
          paymentInfo.billId,
          userId
        ]
      )

      return updateResult.rows.length > 0 ? transformRowToBill(updateResult.rows[0]) : null
    })
  } catch (error) {
    console.error('Error recording bill payment:', error)
    throw new Error('Failed to record bill payment')
  }
}

/**
 * Generate bill for credit card account
 * @description Generates a new bill for a credit card account based on transactions
 * @param accountId - Credit card account ID
 * @param userId - User ID for authorization
 * @param billPeriodStart - Start date of billing period
 * @param billPeriodEnd - End date of billing period
 * @returns Promise resolving to generated credit card bill
 */
export async function generateBillForAccount(
  accountId: string,
  userId: string,
  billPeriodStart: Date,
  billPeriodEnd: Date
): Promise<CreditCardBill> {
  try {
    return await transaction(async (client) => {
      // Get account information
      const accountResult = await client.query(
        'SELECT * FROM accounts WHERE id = $1 AND user_id = $2 AND type = $3',
        [accountId, userId, 'credit_card']
      )

      if (accountResult.rows.length === 0) {
        throw new Error('Credit card account not found')
      }

      const account = accountResult.rows[0]
      const creditCardInfo = {
        billGenerationDate: account.bill_generation_date,
        paymentDueDate: account.payment_due_date
      }

      // Get previous bill to determine previous balance
      const previousBillResult = await client.query(
        `
        SELECT * FROM credit_card_bills 
        WHERE account_id = $1 AND user_id = $2 
        ORDER BY bill_period_end DESC 
        LIMIT 1
        `,
        [accountId, userId]
      )

      // For credit cards, the previous balance should be the unpaid amount from the last bill
      // If this is the first bill, we should start with the current outstanding balance
      const previousBalance = previousBillResult.rows.length > 0 
        ? Math.max(0, previousBillResult.rows[0].bill_amount - previousBillResult.rows[0].paid_amount)
        : Math.max(0, Math.abs(account.current_balance)) // Use current balance as starting point
        


      // Get transactions for the billing period
      const transactionsResult = await client.query(
        `
        SELECT * FROM transactions 
        WHERE account_id = $1 AND user_id = $2 
        AND date >= $3 AND date <= $4
        ORDER BY date ASC
        `,
        [accountId, userId, billPeriodStart.toISOString().split('T')[0], billPeriodEnd.toISOString().split('T')[0]]
      )

      const transactions = transactionsResult.rows
      const transactionIds = transactions.map((t: { id: string }) => t.id)

      // Calculate spending and payments
      let totalSpending = 0
      let totalPayments = 0
      const paymentTransactionIds: string[] = []

      transactions.forEach((transaction: { amount: number; type: string; id: string }) => {
        // For credit cards:
        // - Withdrawals (spending) increase the debt (positive amounts in transactions, but increase bill)
        // - Deposits (payments) reduce the debt (positive amounts that reduce bill)
        if (transaction.type === 'withdrawal') {
          // Credit card spending - increases the amount owed
          totalSpending += transaction.amount
        } else if (transaction.type === 'deposit') {
          // Credit card payment - reduces the amount owed
          totalPayments += transaction.amount
          paymentTransactionIds.push(transaction.id)
        }
      })

      // Calculate bill amount
      const billAmount = Math.max(0, previousBalance + totalSpending - totalPayments)
      const minimumPayment = billAmount > 0 ? calculateMinimumPayment(billAmount) : 0
      


      // Calculate bill generation and due dates
      const billGenerationDate = new Date(billPeriodEnd)
      billGenerationDate.setDate(creditCardInfo.billGenerationDate)
      
      const paymentDueDate = new Date(billGenerationDate)
      paymentDueDate.setDate(creditCardInfo.paymentDueDate)
      if (paymentDueDate <= billGenerationDate) {
        paymentDueDate.setMonth(paymentDueDate.getMonth() + 1)
      }

      // Create the bill
      const billResult = await client.query(
        `
        INSERT INTO credit_card_bills (
          user_id, account_id, bill_period_start, bill_period_end,
          bill_generation_date, payment_due_date, previous_balance,
          total_spending, total_payments, bill_amount, minimum_payment,
          status, paid_amount, transaction_ids, payment_transaction_ids,
          is_auto_generated
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
        ) RETURNING *
        `,
        [
          userId,
          accountId,
          billPeriodStart.toISOString().split('T')[0],
          billPeriodEnd.toISOString().split('T')[0],
          billGenerationDate.toISOString().split('T')[0],
          paymentDueDate.toISOString().split('T')[0],
          previousBalance,
          totalSpending,
          totalPayments,
          billAmount,
          minimumPayment,
          'generated',
          0, // paid_amount
          transactionIds,
          paymentTransactionIds,
          true // is_auto_generated
        ]
      )

      return transformRowToBill(billResult.rows[0])
    })
  } catch (error) {
    console.error('Error generating bill for account:', error)
    throw new Error('Failed to generate bill for account')
  }
}

/**
 * Auto-generate bills for all credit card accounts
 * @description Automatically generates bills for all credit card accounts that need them
 * @param userId - User ID for authorization
 * @returns Promise resolving to array of generated bills
 */
export async function autoGenerateBillsForUser(userId: string): Promise<CreditCardBill[]> {
  try {
    // Get all credit card accounts
    const accounts = await getAccounts(userId)
    const creditCardAccounts = accounts.filter(account => 
      account.type === 'credit_card' && account.creditCardInfo
    )

    const generatedBills: CreditCardBill[] = []
    const today = new Date()

    for (const account of creditCardAccounts) {
      const creditInfo = account.creditCardInfo!
      
      // Check if we need to generate a bill for this account
      const lastBill = await queryOne<CreditCardBillRow>(
        `
        SELECT * FROM credit_card_bills 
        WHERE account_id = $1 AND user_id = $2 
        ORDER BY bill_period_end DESC 
        LIMIT 1
        `,
        [account.id, userId]
      )

      let shouldGenerate = false
      let billPeriodStart: Date
      let billPeriodEnd: Date

      if (!lastBill) {
        // No previous bill, generate first bill
        shouldGenerate = true
        billPeriodStart = new Date(account.accountOpeningDate)
        billPeriodEnd = new Date(today.getFullYear(), today.getMonth(), creditInfo.billGenerationDate)
        
        // If bill generation date hasn't passed this month, use last month
        if (billPeriodEnd > today) {
          billPeriodEnd.setMonth(billPeriodEnd.getMonth() - 1)
        }
      } else {
        // Check if we need to generate next bill
        const lastBillEnd = new Date(lastBill.bill_period_end)
        const nextBillGeneration = new Date(lastBillEnd)
        nextBillGeneration.setMonth(nextBillGeneration.getMonth() + 1)
        nextBillGeneration.setDate(creditInfo.billGenerationDate)

        if (nextBillGeneration <= today) {
          shouldGenerate = true
          billPeriodStart = new Date(lastBillEnd)
          billPeriodStart.setDate(billPeriodStart.getDate() + 1)
          billPeriodEnd = new Date(nextBillGeneration)
        }
      }

      if (shouldGenerate) {
        try {
          const bill = await generateBillForAccount(account.id, userId, billPeriodStart!, billPeriodEnd!)
          generatedBills.push(bill)
        } catch (error) {
          console.error(`Error generating bill for account ${account.id}:`, error)
          // Continue with other accounts
        }
      }
    }

    return generatedBills
  } catch (error) {
    console.error('Error auto-generating bills:', error)
    throw new Error('Failed to auto-generate bills')
  }
} 