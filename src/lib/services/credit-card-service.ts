/**
 * @file credit-card-service.ts
 * @description This file contains the credit card bill management service functions.
 * It provides bill generation, payment tracking, and credit card overview functionality.
 */

import { supabase } from '@/lib/supabase'
import { 
  CreditCardBill, 
  CreditCardSummary, 
  BillGenerationParams,
  BillPaymentInfo,
  calculateMinimumPayment,
  determineBillStatus,
  getNextBillDates
} from '@/types/credit-card'
import { Account } from '@/types/account'
import { getAccounts } from './supabase-account-service'
import { getTransactions } from './supabase-transaction-service'
import { formatDateForDatabase, parseDateFromDatabase } from '@/lib/utils'
import { subMonths, format } from 'date-fns'

/**
 * Database row interface for credit_card_bills table
 * @description Maps to the credit_card_bills table structure in Supabase
 */
interface CreditCardBillRow {
  id: string
  user_id: string
  account_id: string
  bill_period_start: string
  bill_period_end: string
  bill_generation_date: string
  payment_due_date: string
  previous_balance: number
  total_spending: number
  total_payments: number
  bill_amount: number
  minimum_payment: number
  status: string
  paid_amount: number
  paid_date: string | null
  transaction_ids: string[]
  payment_transaction_ids: string[]
  is_auto_generated: boolean
  notes: string | null
  created_at: string
  updated_at: string
}

/**
 * Transform database row to CreditCardBill object
 * @description Converts database row format to application CreditCardBill interface
 * @param row - Database row from credit_card_bills table
 * @returns CreditCardBill object
 */
function transformRowToBill(row: CreditCardBillRow): CreditCardBill {
  return {
    id: row.id,
    userId: row.user_id,
    accountId: row.account_id,
    billPeriodStart: parseDateFromDatabase(row.bill_period_start),
    billPeriodEnd: parseDateFromDatabase(row.bill_period_end),
    billGenerationDate: parseDateFromDatabase(row.bill_generation_date),
    paymentDueDate: parseDateFromDatabase(row.payment_due_date),
    previousBalance: row.previous_balance,
    totalSpending: row.total_spending,
    totalPayments: row.total_payments,
    billAmount: row.bill_amount,
    minimumPayment: row.minimum_payment,
    status: row.status as CreditCardBill['status'],
    paidAmount: row.paid_amount,
    paidDate: row.paid_date ? parseDateFromDatabase(row.paid_date) : undefined,
    transactionIds: row.transaction_ids,
    paymentTransactionIds: row.payment_transaction_ids,
    isAutoGenerated: row.is_auto_generated,
    notes: row.notes || undefined,
    createdAt: new Date(row.created_at),
    updatedAt: new Date(row.updated_at),
  }
}

/**
 * Get all credit card accounts for a user
 * @description Retrieves all credit card accounts belonging to the user
 * @param userId - User ID to filter accounts
 * @returns Promise resolving to array of credit card accounts
 */
export async function getCreditCardAccounts(userId: string): Promise<Account[]> {
  const accounts = await getAccounts(userId)
  return accounts.filter(account => account.type === 'credit_card' && account.creditCardInfo)
}

/**
 * Get credit card bills for an account
 * @description Retrieves all bills for a specific credit card account
 * @param accountId - Credit card account ID
 * @param userId - User ID for authorization
 * @returns Promise resolving to array of bills
 */
export async function getCreditCardBills(accountId: string, userId: string): Promise<CreditCardBill[]> {
  const { data, error } = await supabase
    .from('credit_card_bills')
    .select('*')
    .eq('account_id', accountId)
    .eq('user_id', userId)
    .order('bill_generation_date', { ascending: false })

  if (error) {
    console.error('Error fetching credit card bills:', error)
    throw new Error(`Failed to fetch credit card bills: ${error.message}`)
  }

  return data.map(transformRowToBill)
}

/**
 * Get all credit card bills for a user
 * @description Retrieves all bills across all credit card accounts for a user
 * @param userId - User ID to filter bills
 * @returns Promise resolving to array of bills
 */
export async function getAllCreditCardBills(userId: string): Promise<CreditCardBill[]> {
  const { data, error } = await supabase
    .from('credit_card_bills')
    .select('*')
    .eq('user_id', userId)
    .order('bill_generation_date', { ascending: false })

  if (error) {
    console.error('Error fetching all credit card bills:', error)
    throw new Error(`Failed to fetch credit card bills: ${error.message}`)
  }

  return data.map(transformRowToBill)
}

/**
 * Generate credit card bill for a specific period
 * @description Creates a new bill based on transactions in the specified period
 * @param params - Bill generation parameters
 * @param userId - User ID for authorization
 * @returns Promise resolving to generated bill
 */
export async function generateCreditCardBill(params: BillGenerationParams, userId: string): Promise<CreditCardBill> {
  const { accountId, billPeriodStart, billPeriodEnd, billGenerationDate, paymentDueDate, previousBalance = 0 } = params

  // Get all transactions for the account in the bill period
  const allTransactions = await getTransactions(userId)
  const accountTransactions = allTransactions.filter(transaction => {
    const transactionDate = new Date(transaction.date)
    const isInPeriod = transactionDate >= billPeriodStart && transactionDate <= billPeriodEnd
    const isForAccount = transaction.accountId === accountId || 
                        transaction.fromAccountId === accountId || 
                        transaction.toAccountId === accountId
    const isCompleted = transaction.status === 'completed'
    
    return isInPeriod && isForAccount && isCompleted
  })

  // Calculate spending and payments
  let totalSpending = 0
  let totalPayments = 0
  const transactionIds: string[] = []

  accountTransactions.forEach(transaction => {
    transactionIds.push(transaction.id)
    
    if (transaction.type === 'withdrawal' && transaction.accountId === accountId) {
      // Spending on credit card
      totalSpending += transaction.amount
    } else if (transaction.type === 'deposit' && transaction.accountId === accountId) {
      // Payment to credit card
      totalPayments += transaction.amount
    } else if (transaction.type === 'transfer') {
      if (transaction.fromAccountId === accountId) {
        // Transfer from credit card (cash advance - treated as spending)
        totalSpending += transaction.amount
      } else if (transaction.toAccountId === accountId) {
        // Transfer to credit card (payment)
        totalPayments += transaction.amount
      }
    }
  })

  // Calculate bill amount
  const billAmount = previousBalance + totalSpending - totalPayments

  // Get account for minimum payment calculation
  const accounts = await getAccounts(userId)
  const account = accounts.find(acc => acc.id === accountId)
  if (!account || !account.creditCardInfo) {
    throw new Error('Credit card account not found or invalid')
  }

  const minimumPayment = calculateMinimumPayment(billAmount)

  // Create bill record
  const billData = {
    user_id: userId,
    account_id: accountId,
    bill_period_start: formatDateForDatabase(billPeriodStart),
    bill_period_end: formatDateForDatabase(billPeriodEnd),
    bill_generation_date: formatDateForDatabase(billGenerationDate),
    payment_due_date: formatDateForDatabase(paymentDueDate),
    previous_balance: previousBalance,
    total_spending: totalSpending,
    total_payments: totalPayments,
    bill_amount: billAmount,
    minimum_payment: minimumPayment,
    status: 'generated',
    paid_amount: 0,
    paid_date: null,
    transaction_ids: transactionIds,
    payment_transaction_ids: [],
    is_auto_generated: true,
    notes: null,
  }

  const { data, error } = await supabase
    .from('credit_card_bills')
    .insert(billData)
    .select()
    .single()

  if (error) {
    console.error('Error creating credit card bill:', error)
    throw new Error(`Failed to create credit card bill: ${error.message}`)
  }

  return transformRowToBill(data)
}

/**
 * Auto-generate bills for all credit cards that need them
 * @description Automatically generates bills for credit cards based on their bill generation dates
 * @param userId - User ID to process
 * @returns Promise resolving to array of generated bills
 */
export async function autoGenerateBills(userId: string): Promise<CreditCardBill[]> {
  const creditCardAccounts = await getCreditCardAccounts(userId)
  const generatedBills: CreditCardBill[] = []

  for (const account of creditCardAccounts) {
    if (!account.creditCardInfo) continue

    const { billGenerationDate, paymentDueDate } = account.creditCardInfo
    const currentDate = new Date()
    const { nextBillGenerationDate, nextPaymentDueDate } = getNextBillDates(billGenerationDate, paymentDueDate, currentDate)

    // Check if we need to generate a bill for the previous period
    const lastBillPeriodEnd = new Date(nextBillGenerationDate.getFullYear(), nextBillGenerationDate.getMonth() - 1, billGenerationDate - 1)
    const lastBillPeriodStart = new Date(lastBillPeriodEnd.getFullYear(), lastBillPeriodEnd.getMonth() - 1, billGenerationDate)

    // Check if bill already exists for this period
    const existingBills = await getCreditCardBills(account.id, userId)
    const billExists = existingBills.some(bill => 
      format(bill.billPeriodStart, 'yyyy-MM-dd') === format(lastBillPeriodStart, 'yyyy-MM-dd') &&
      format(bill.billPeriodEnd, 'yyyy-MM-dd') === format(lastBillPeriodEnd, 'yyyy-MM-dd')
    )

    if (!billExists && currentDate >= nextBillGenerationDate) {
      // Get previous balance from last bill
      const previousBill = existingBills[0] // Most recent bill
      const previousBalance = previousBill ? previousBill.billAmount - previousBill.paidAmount : 0

      try {
        const generatedBill = await generateCreditCardBill({
          accountId: account.id,
          billPeriodStart: lastBillPeriodStart,
          billPeriodEnd: lastBillPeriodEnd,
          billGenerationDate: nextBillGenerationDate,
          paymentDueDate: nextPaymentDueDate,
          previousBalance
        }, userId)

        generatedBills.push(generatedBill)
      } catch (error) {
        console.error(`Failed to auto-generate bill for account ${account.name}:`, error)
      }
    }
  }

  return generatedBills
}

/**
 * Mark bill as paid
 * @description Records a payment against a credit card bill
 * @param paymentInfo - Payment information
 * @param userId - User ID for authorization
 * @returns Promise resolving to updated bill
 */
export async function markBillAsPaid(paymentInfo: BillPaymentInfo, userId: string): Promise<CreditCardBill | null> {
  const { billId, paymentAmount, paymentDate, paymentTransactionId, notes } = paymentInfo

  // Get current bill
  const { data: currentBill, error: fetchError } = await supabase
    .from('credit_card_bills')
    .select('*')
    .eq('id', billId)
    .eq('user_id', userId)
    .single()

  if (fetchError || !currentBill) {
    console.error('Error fetching bill:', fetchError)
    return null
  }

  const bill = transformRowToBill(currentBill)
  const newPaidAmount = bill.paidAmount + paymentAmount
  const newStatus = determineBillStatus(bill.billAmount, newPaidAmount, bill.paymentDueDate)

  // Update payment transaction IDs
  const paymentTransactionIds = [...bill.paymentTransactionIds]
  if (paymentTransactionId) {
    paymentTransactionIds.push(paymentTransactionId)
  }

  const updateData = {
    paid_amount: newPaidAmount,
    paid_date: newPaidAmount >= bill.billAmount ? formatDateForDatabase(paymentDate) : null,
    status: newStatus,
    payment_transaction_ids: paymentTransactionIds,
    notes: notes || bill.notes,
    updated_at: new Date().toISOString()
  }

  const { data, error } = await supabase
    .from('credit_card_bills')
    .update(updateData)
    .eq('id', billId)
    .eq('user_id', userId)
    .select()
    .single()

  if (error) {
    console.error('Error updating bill payment:', error)
    throw new Error(`Failed to update bill payment: ${error.message}`)
  }

  return transformRowToBill(data)
}

/**
 * Get credit card summary for all accounts
 * @description Provides comprehensive overview of all credit card accounts
 * @param userId - User ID to fetch data for
 * @returns Promise resolving to array of credit card summaries
 */
export async function getCreditCardSummaries(userId: string): Promise<CreditCardSummary[]> {
  const [creditCardAccounts, allBills, allTransactions] = await Promise.all([
    getCreditCardAccounts(userId),
    getAllCreditCardBills(userId),
    getTransactions(userId)
  ])

  const summaries: CreditCardSummary[] = []

  for (const account of creditCardAccounts) {
    if (!account.creditCardInfo) continue

    const accountBills = allBills.filter(bill => bill.accountId === account.id)
    const recentBills = accountBills.slice(0, 6) // Last 6 bills

    // Find current unpaid bill
    const currentBill = accountBills.find(bill => 
      bill.status === 'generated' || bill.status === 'partial' || bill.status === 'overdue'
    )

    // Calculate next bill dates
    const { nextBillGenerationDate, nextPaymentDueDate } = getNextBillDates(
      account.creditCardInfo.billGenerationDate,
      account.creditCardInfo.paymentDueDate
    )

    // Calculate usage statistics
    const currentDate = new Date()
    const lastMonth = subMonths(currentDate, 1)
    const lastMonthTransactions = allTransactions.filter(transaction => {
      const transactionDate = new Date(transaction.date)
      return transaction.accountId === account.id &&
             transaction.type === 'withdrawal' &&
             transaction.status === 'completed' &&
             transactionDate >= lastMonth && transactionDate < currentDate
    })

    const lastMonthSpending = lastMonthTransactions.reduce((sum, t) => sum + t.amount, 0)
    
    // Calculate average spending from recent bills
    const spendingAmounts = recentBills.map(bill => bill.totalSpending).filter(amount => amount > 0)
    const monthlyAverageSpending = spendingAmounts.length > 0 
      ? spendingAmounts.reduce((sum, amount) => sum + amount, 0) / spendingAmounts.length 
      : 0

    // Calculate spending trend
    const spendingTrend = monthlyAverageSpending > 0 
      ? ((lastMonthSpending - monthlyAverageSpending) / monthlyAverageSpending) * 100 
      : 0

    summaries.push({
      account,
      currentBalance: account.currentBalance,
      creditLimit: account.creditCardInfo.creditLimit,
      availableCredit: account.creditCardInfo.creditLimit + account.currentBalance, // currentBalance is negative for debt
      creditUsagePercentage: account.creditCardInfo.creditUsagePercentage,
      currentBill,
      nextBillGenerationDate,
      nextPaymentDueDate,
      recentBills,
      monthlyAverageSpending,
      lastMonthSpending,
      spendingTrend
    })
  }

  return summaries
}

/**
 * Delete credit card bill
 * @description Deletes a credit card bill (for manual cleanup)
 * @param billId - Bill ID to delete
 * @param userId - User ID for authorization
 * @returns Promise resolving to success status
 */
export async function deleteCreditCardBill(billId: string, userId: string): Promise<boolean> {
  const { error } = await supabase
    .from('credit_card_bills')
    .delete()
    .eq('id', billId)
    .eq('user_id', userId)

  if (error) {
    console.error('Error deleting credit card bill:', error)
    throw new Error(`Failed to delete credit card bill: ${error.message}`)
  }

  return true
} 